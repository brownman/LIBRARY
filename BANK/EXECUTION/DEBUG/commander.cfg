commander_test(){
    commander echo hi
}
commander_end(){
    commander $@
    commander flite -t finish
    pipe_translate finish
}
commander2(){
    local str_caller="`caller`"
    local cmd_clip="gvim +${str_caller}"

    commander $@ 2>/tmp/err
    local res=$?
    test $res -eq 0 || $( gxmessage -file /tmp/err -entrytext "$cmd_clip" -title 'commander: Error' )
}
commander(){
#pending: commander add a space char - find out why!
    use_many indicator print trace
    local args=( $@ )
    local cmd="${args[@]}"
#echo 1>&2 $cmd
    print color 34 [cmd] $cmd
    echo "[ gvim +${str_caller} ] $cmd" >> /tmp/trace
    $cmd

    local res="$?"
    indicator $res
    return $res
}
commander_n(){
    local args=( $@ )
    local cmd="${args[@]}"
    printn color 34 "[cmd] $cmd"
    #setting e + 
    echo "$cmd" >> /tmp/trace
    #eval "$cmd"
    $cmd
    local res="$?"
    indicator $res
    return $res
}
commander_lock_file(){

    print func
    local file=${1:-$0}

    print color 33 allow only 1 instance of this command
    naming $file
    locking $file

    trap unlocking SIGTERM
    trap unlocking SIGINT
    trap unlocking EXIT
    if [ $# -gt 1 ];then

        shift
        local args=( $@ )
        local cmd="${args[@]:-}"
        commander "bash -c $file $cmd" 
    else
        commander "bash -c $file"
    fi
    #commander unlocking
}
commander1(){
    local args=( $@ ) 
    local cmd="${args[@]}"
    commander "$cmd" || ( print error "$cmd" ; )
}
commander_fallback(){
    use assert
    use print
    use commander

    assert left_bigger "$#" 1
    local cmd_fallback="$1"
    shift
    local args=( $@ ) 
    local cmd="${args[@]}"
    commander "$cmd" || { print error "$cmd" ; print color 33 "fallback to: $cmd_fallback"; $cmd_fallback; }


}

export -f commander
export -f commander_fallback
export -f commander_n
export -f commander_lock_file
export -f commander1
