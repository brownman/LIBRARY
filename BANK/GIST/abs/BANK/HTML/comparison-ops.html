<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Other Comparison Operators</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Tests"
HREF="tests.html"><LINK
REL="PREVIOUS"
TITLE="File test operators"
HREF="fto.html"><LINK
REL="NEXT"
TITLE="Nested if/then Condition Tests"
HREF="nestedifthen.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="fto.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 7. Tests</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="nestedifthen.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="COMPARISON-OPS"
></A
>7.3. Other Comparison Operators</H1
><P
>A <I
CLASS="FIRSTTERM"
>binary</I
> comparison operator
	  compares two variables or quantities. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Note
	  that integer and string comparison use a different set of
	  operators.</I
></SPAN
></P
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="ICOMPARISON1"
></A
>integer comparison</B
></P
><DL
><DT
><A
NAME="EQUALREF"
></A
><SPAN
CLASS="TOKEN"
>-eq</SPAN
></DT
><DD
><P
>is equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" -eq "$b" ]</B
></TT
></P
></DD
><DT
><A
NAME="NEQUALREF"
></A
><SPAN
CLASS="TOKEN"
>-ne</SPAN
></DT
><DD
><P
>is not equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" -ne "$b" ]</B
></TT
></P
></DD
><DT
><A
NAME="GT0REF"
></A
><SPAN
CLASS="TOKEN"
>-gt</SPAN
></DT
><DD
><P
>is greater than</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" -gt "$b" ]</B
></TT
></P
></DD
><DT
><A
NAME="GE0REF"
></A
><SPAN
CLASS="TOKEN"
>-ge</SPAN
></DT
><DD
><P
>is greater than or equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" -ge "$b" ]</B
></TT
></P
></DD
><DT
><A
NAME="LT0REF"
></A
><SPAN
CLASS="TOKEN"
>-lt</SPAN
></DT
><DD
><P
>is less than</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" -lt "$b" ]</B
></TT
></P
></DD
><DT
><A
NAME="LE0REF"
></A
><SPAN
CLASS="TOKEN"
>-le</SPAN
></DT
><DD
><P
>is less than or equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" -le "$b" ]</B
></TT
></P
></DD
><DT
><A
NAME="INTLT"
></A
><SPAN
CLASS="TOKEN"
>&#60;</SPAN
></DT
><DD
><P
>is less than (within <A
HREF="dblparens.html"
>double
	      parentheses</A
>)</P
><P
><TT
CLASS="USERINPUT"
><B
>(("$a" &#60; "$b"))</B
></TT
></P
></DD
><DT
><A
NAME="LTEQ"
></A
><SPAN
CLASS="TOKEN"
>&#60;=</SPAN
></DT
><DD
><P
>is less than or equal to (within double parentheses)</P
><P
><TT
CLASS="USERINPUT"
><B
>(("$a" &#60;= "$b"))</B
></TT
></P
></DD
><DT
><A
NAME="INTGT"
></A
><SPAN
CLASS="TOKEN"
>&#62;</SPAN
></DT
><DD
><P
>is greater than (within double parentheses)</P
><P
><TT
CLASS="USERINPUT"
><B
>(("$a" &#62; "$b"))</B
></TT
></P
></DD
><DT
><A
NAME="GTEQ"
></A
><SPAN
CLASS="TOKEN"
>&#62;=</SPAN
></DT
><DD
><P
>is greater than or equal to (within double parentheses)</P
><P
><TT
CLASS="USERINPUT"
><B
>(("$a" &#62;= "$b"))</B
></TT
></P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="SCOMPARISON1"
></A
>string comparison</B
></P
><DL
><DT
><SPAN
CLASS="TOKEN"
>=</SPAN
></DT
><DD
><P
><A
NAME="EQUALSIGNREF"
></A
></P
><P
>is equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" = "$b" ]</B
></TT
></P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Note the <A
HREF="special-chars.html#WHITESPACEREF"
>whitespace</A
>
              framing the <B
CLASS="COMMAND"
>=</B
>.</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a"="$b" ]</B
></TT
> is
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> equivalent to the
              above.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="SCOMPARISON2"
></A
><SPAN
CLASS="TOKEN"
>==</SPAN
></DT
><DD
><P
>is equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" == "$b" ]</B
></TT
></P
><P
>This is a synonym for <SPAN
CLASS="TOKEN"
>=</SPAN
>.</P
><DIV
CLASS="NOTE"
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/note.png"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>	      The <SPAN
CLASS="TOKEN"
>==</SPAN
> comparison operator behaves differently
	      within a <A
HREF="tests.html#DBLBRACKETS"
>double-brackets</A
>
	      test than within single brackets.
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;[[ $a == z* ]]   # True if $a starts with an "z" (pattern matching).
   2&nbsp;[[ $a == "z*" ]] # True if $a is equal to z* (literal matching).
   3&nbsp;
   4&nbsp;[ $a == z* ]     # File globbing and word splitting take place.
   5&nbsp;[ "$a" == "z*" ] # True if $a is equal to z* (literal matching).
   6&nbsp;
   7&nbsp;# Thanks, Stéphane Chazelas</PRE
></TD
></TR
></TABLE
>
              </P
></TD
></TR
></TABLE
></DIV
></DD
><DT
><A
NAME="NOTEQUAL"
></A
><SPAN
CLASS="TOKEN"
>!=</SPAN
></DT
><DD
><P
>is not equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" != "$b" ]</B
></TT
></P
><P
>This operator uses pattern matching within a <A
HREF="tests.html#DBLBRACKETS"
>[[ ... ]]</A
> construct.</P
></DD
><DT
><A
NAME="LTREF"
></A
><SPAN
CLASS="TOKEN"
>&#60;</SPAN
></DT
><DD
><P
>is less than, in <A
HREF="special-chars.html#ASCIIDEF"
>ASCII</A
> alphabetical
		    order</P
><P
><TT
CLASS="USERINPUT"
><B
>if [[ "$a" &#60; "$b" ]]</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" \&#60; "$b" ]</B
></TT
></P
><P
>Note that the <SPAN
CLASS="QUOTE"
>"&#60;"</SPAN
> needs to be
	      <A
HREF="escapingsection.html#ESCP"
>escaped</A
> within a
	      <TT
CLASS="USERINPUT"
><B
>[  ]</B
></TT
> construct.</P
></DD
><DT
><A
NAME="GTREF"
></A
><SPAN
CLASS="TOKEN"
>&#62;</SPAN
></DT
><DD
><P
>is greater than, in ASCII alphabetical order</P
><P
><TT
CLASS="USERINPUT"
><B
>if [[ "$a" &#62; "$b" ]]</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" \&#62; "$b" ]</B
></TT
></P
><P
>Note that the <SPAN
CLASS="QUOTE"
>"&#62;"</SPAN
> needs to be
	      escaped within a <TT
CLASS="USERINPUT"
><B
>[  ]</B
></TT
> construct.</P
><P
>See <A
HREF="arrays.html#BUBBLE"
>Example 27-11</A
> for an application of this
	      comparison operator.</P
></DD
><DT
><A
NAME="STRINGNULL"
></A
><SPAN
CLASS="TOKEN"
>-z</SPAN
></DT
><DD
><P
>string is <I
CLASS="FIRSTTERM"
>null</I
>,
	        that is, has zero length</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp; String=''   # Zero-length ("null") string variable.
   2&nbsp;
   3&nbsp;if [ -z "$String" ]
   4&nbsp;then
   5&nbsp;  echo "\$String is null."
   6&nbsp;else
   7&nbsp;  echo "\$String is NOT null."
   8&nbsp;fi     # $String is null.</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><A
NAME="STRINGNOTNULL"
></A
><SPAN
CLASS="TOKEN"
>-n</SPAN
></DT
><DD
><P
>string is not <I
CLASS="FIRSTTERM"
>null.</I
></P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="USERINPUT"
><B
>-n</B
></TT
> test
		requires that the string be quoted within the
		test brackets. Using an unquoted string with
		<I
CLASS="FIRSTTERM"
>! -z</I
>, or even just the
		unquoted string alone within test brackets (see <A
HREF="comparison-ops.html#STRTEST"
>Example 7-6</A
>) normally works, however, this is
		an unsafe practice. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Always</I
></SPAN
> quote
		a tested string.
		  <A
NAME="AEN3647"
HREF="#FTN.AEN3647"
>[1]</A
>
		</P
></TD
></TR
></TABLE
></DIV
></DD
></DL
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX13"
></A
><P
><B
>Example 7-5. Arithmetic and string comparisons</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;a=4
   4&nbsp;b=5
   5&nbsp;
   6&nbsp;#  Here "a" and "b" can be treated either as integers or strings.
   7&nbsp;#  There is some blurring between the arithmetic and string comparisons,
   8&nbsp;#+ since Bash variables are not strongly typed.
   9&nbsp;
  10&nbsp;#  Bash permits integer operations and comparisons on variables
  11&nbsp;#+ whose value consists of all-integer characters.
  12&nbsp;#  Caution advised, however.
  13&nbsp;
  14&nbsp;echo
  15&nbsp;
  16&nbsp;if [ "$a" -ne "$b" ]
  17&nbsp;then
  18&nbsp;  echo "$a is not equal to $b"
  19&nbsp;  echo "(arithmetic comparison)"
  20&nbsp;fi
  21&nbsp;
  22&nbsp;echo
  23&nbsp;
  24&nbsp;if [ "$a" != "$b" ]
  25&nbsp;then
  26&nbsp;  echo "$a is not equal to $b."
  27&nbsp;  echo "(string comparison)"
  28&nbsp;  #     "4"  != "5"
  29&nbsp;  # ASCII 52 != ASCII 53
  30&nbsp;fi
  31&nbsp;
  32&nbsp;# In this particular instance, both "-ne" and "!=" work.
  33&nbsp;
  34&nbsp;echo
  35&nbsp;
  36&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="STRTEST"
></A
><P
><B
>Example 7-6. Testing whether a string is <I
CLASS="FIRSTTERM"
>null</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;#  str-test.sh: Testing null strings and unquoted strings,
   3&nbsp;#+ but not strings and sealing wax, not to mention cabbages and kings . . .
   4&nbsp;
   5&nbsp;# Using   if [ ... ]
   6&nbsp;
   7&nbsp;# If a string has not been initialized, it has no defined value.
   8&nbsp;# This state is called "null" (not the same as zero!).
   9&nbsp;
  10&nbsp;if [ -n $string1 ]    # string1 has not been declared or initialized.
  11&nbsp;then
  12&nbsp;  echo "String \"string1\" is not null."
  13&nbsp;else  
  14&nbsp;  echo "String \"string1\" is null."
  15&nbsp;fi                    # Wrong result.
  16&nbsp;# Shows $string1 as not null, although it was not initialized.
  17&nbsp;
  18&nbsp;echo
  19&nbsp;
  20&nbsp;# Let's try it again.
  21&nbsp;
  22&nbsp;if [ -n "$string1" ]  # This time, $string1 is quoted.
  23&nbsp;then
  24&nbsp;  echo "String \"string1\" is not null."
  25&nbsp;else  
  26&nbsp;  echo "String \"string1\" is null."
  27&nbsp;fi                    # Quote strings within test brackets!
  28&nbsp;
  29&nbsp;echo
  30&nbsp;
  31&nbsp;if [ $string1 ]       # This time, $string1 stands naked.
  32&nbsp;then
  33&nbsp;  echo "String \"string1\" is not null."
  34&nbsp;else  
  35&nbsp;  echo "String \"string1\" is null."
  36&nbsp;fi                    # This works fine.
  37&nbsp;# The [ ... ] test operator alone detects whether the string is null.
  38&nbsp;# However it is good practice to quote it (if [ "$string1" ]).
  39&nbsp;#
  40&nbsp;# As Stephane Chazelas points out,
  41&nbsp;#    if [ $string1 ]    has one argument, "]"
  42&nbsp;#    if [ "$string1" ]  has two arguments, the empty "$string1" and "]" 
  43&nbsp;
  44&nbsp;
  45&nbsp;echo
  46&nbsp;
  47&nbsp;
  48&nbsp;string1=initialized
  49&nbsp;
  50&nbsp;if [ $string1 ]       # Again, $string1 stands unquoted.
  51&nbsp;then
  52&nbsp;  echo "String \"string1\" is not null."
  53&nbsp;else  
  54&nbsp;  echo "String \"string1\" is null."
  55&nbsp;fi                    # Again, gives correct result.
  56&nbsp;# Still, it is better to quote it ("$string1"), because . . .
  57&nbsp;
  58&nbsp;
  59&nbsp;string1="a = b"
  60&nbsp;
  61&nbsp;if [ $string1 ]       # Again, $string1 stands unquoted.
  62&nbsp;then
  63&nbsp;  echo "String \"string1\" is not null."
  64&nbsp;else  
  65&nbsp;  echo "String \"string1\" is null."
  66&nbsp;fi                    # Not quoting "$string1" now gives wrong result!
  67&nbsp;
  68&nbsp;exit 0   # Thank you, also, Florian Wisser, for the "heads-up".</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX14"
></A
><P
><B
>Example 7-7. <I
CLASS="FIRSTTERM"
>zmore</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# zmore
   3&nbsp;
   4&nbsp;# View gzipped files with 'more' filter.
   5&nbsp;
   6&nbsp;E_NOARGS=85
   7&nbsp;E_NOTFOUND=86
   8&nbsp;E_NOTGZIP=87
   9&nbsp;
  10&nbsp;if [ $# -eq 0 ] # same effect as:  if [ -z "$1" ]
  11&nbsp;# $1 can exist, but be empty:  zmore "" arg2 arg3
  12&nbsp;then
  13&nbsp;  echo "Usage: `basename $0` filename" &#62;&#38;2
  14&nbsp;  # Error message to stderr.
  15&nbsp;  exit $E_NOARGS
  16&nbsp;  # Returns 85 as exit status of script (error code).
  17&nbsp;fi  
  18&nbsp;
  19&nbsp;filename=$1
  20&nbsp;
  21&nbsp;if [ ! -f "$filename" ]   # Quoting $filename allows for possible spaces.
  22&nbsp;then
  23&nbsp;  echo "File $filename not found!" &#62;&#38;2   # Error message to stderr.
  24&nbsp;  exit $E_NOTFOUND
  25&nbsp;fi  
  26&nbsp;
  27&nbsp;if [ ${filename##*.} != "gz" ]
  28&nbsp;# Using bracket in variable substitution.
  29&nbsp;then
  30&nbsp;  echo "File $1 is not a gzipped file!"
  31&nbsp;  exit $E_NOTGZIP
  32&nbsp;fi  
  33&nbsp;
  34&nbsp;zcat $1 | more
  35&nbsp;
  36&nbsp;# Uses the 'more' filter.
  37&nbsp;# May substitute 'less' if desired.
  38&nbsp;
  39&nbsp;exit $?   # Script returns exit status of pipe.
  40&nbsp;#  Actually "exit $?" is unnecessary, as the script will, in any case,
  41&nbsp;#+ return the exit status of the last command executed.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="CCOMPARISON1"
></A
>compound comparison</B
></P
><DL
><DT
><A
NAME="COMPOUNDAND"
></A
><SPAN
CLASS="TOKEN"
>-a</SPAN
></DT
><DD
><P
>logical and</P
><P
><TT
CLASS="REPLACEABLE"
><I
>exp1 -a exp2</I
></TT
> returns true if
		<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>both</I
></SPAN
> exp1 and exp2 are true.</P
></DD
><DT
><A
NAME="COMPOUNDOR"
></A
><SPAN
CLASS="TOKEN"
>-o</SPAN
></DT
><DD
><P
>logical or </P
><P
><TT
CLASS="REPLACEABLE"
><I
>exp1 -o exp2</I
></TT
> returns
		true if either exp1 <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>or</I
></SPAN
> exp2 is
		true.</P
></DD
></DL
></DIV
><P
>         These are similar to the Bash comparison operators
	 <B
CLASS="COMMAND"
>&#38;&#38;</B
> and <B
CLASS="COMMAND"
>||</B
>, used
	 within <A
HREF="tests.html#DBLBRACKETS"
>double brackets</A
>.
	   <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;[[ condition1 &#38;&#38; condition2 ]]</PRE
></TD
></TR
></TABLE
>
       </P
><P
>	 The <B
CLASS="COMMAND"
>-o</B
> and <B
CLASS="COMMAND"
>-a</B
> operators
	 work with the <A
HREF="tests.html#TTESTREF"
>test</A
> command or
	 occur within single test brackets.
         <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;if [ "$expr1" -a "$expr2" ]
   2&nbsp;then
   3&nbsp;  echo "Both expr1 and expr2 are true."
   4&nbsp;else
   5&nbsp;  echo "Either expr1 or expr2 is false."
   6&nbsp;fi</PRE
></TD
></TR
></TABLE
>
	   </P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>But, as <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>rihad</I
></SPAN
> points out:
<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;[ 1 -eq 1 ] &#38;&#38; [ -n "`echo true 1&#62;&#38;2`" ]   # true
   2&nbsp;[ 1 -eq 2 ] &#38;&#38; [ -n "`echo true 1&#62;&#38;2`" ]   # (no output)
   3&nbsp;# ^^^^^^^ False condition. So far, everything as expected.
   4&nbsp;
   5&nbsp;# However ...
   6&nbsp;[ 1 -eq 2 -a -n "`echo true 1&#62;&#38;2`" ]       # true
   7&nbsp;# ^^^^^^^ False condition. So, why "true" output?
   8&nbsp;
   9&nbsp;# Is it because both condition clauses within brackets evaluate?
  10&nbsp;[[ 1 -eq 2 &#38;&#38; -n "`echo true 1&#62;&#38;2`" ]]     # (no output)
  11&nbsp;# No, that's not it.
  12&nbsp;
  13&nbsp;# Apparently &#38;&#38; and || "short-circuit" while -a and -o do not.</PRE
></TD
></TR
></TABLE
>
	   </P
></TD
></TR
></TABLE
></DIV
><P
>Refer to <A
HREF="operations.html#ANDOR"
>Example 8-3</A
>, <A
HREF="arrays.html#TWODIM"
>Example 27-17</A
>,
	 and <A
HREF="contributed-scripts.html#WHX"
>Example A-29</A
> to see compound comparison operators
	 in action.</P
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN3647"
HREF="comparison-ops.html#AEN3647"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>As S.C. points out, in a compound test,
		    even quoting the string variable might not
		    suffice. <TT
CLASS="USERINPUT"
><B
>[ -n "$string" -o "$a" = "$b" ]</B
></TT
>
		    may cause an error with some versions of Bash if
		    <TT
CLASS="VARNAME"
>$string</TT
> is empty. The safe way
		    is to append an extra character to possibly empty variables,
		    <TT
CLASS="USERINPUT"
><B
>[ "x$string" != x -o "x$a" = "x$b" ]</B
></TT
>
		    (the <SPAN
CLASS="QUOTE"
>"x's"</SPAN
> cancel out).</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="fto.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="nestedifthen.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>File test operators</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="tests.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Nested <TT
CLASS="REPLACEABLE"
><I
>if/then</I
></TT
> Condition Tests</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>