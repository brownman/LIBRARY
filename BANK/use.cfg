#alias useE="gvim $BASH_SOURCE"
#alias useS="source $BASH_SOURCE"

use_test(){
  local func=${1:-assert}
  use $func 
    type $func 1>/dev/null
    echo $?

}
use_many(){
  for item in $@;do
    use $item
      done
}

use(){
  set -o nounset
#print_func
#pushd `dirname $0` >/dev/null
#  use trap_err
    local str
    local str_caller="`caller`"

    local str0
    local cmd
    local type
    local res
#  local dir_self=$dir_CODE

    local file
    local res=1

    str0="${1:-}"

    local act="${2:-}" #edit?
    test $# -gt 0 || { tree -L 2 $dir_CODE/ ; exit 0; }

#echo 1>&2 $str0

  local funcname="`basename $str0`"
    ( set -o pipefail;  exec &>/dev/null;  type $funcname | grep function )
    res=$?
    if [ $res -eq 0 ] && [ "$act" != edit ] && [ "$act" != force ];then
      return 0
        fi
        cmd="finder $str0"
#echo "[CMD] $cmd"
        str=$( eval "$cmd" )


        if [ -n "$str" ];then
          file="$str"
            if [ -f "$file" ];then
# ( ln -s $file $dir_root/MUST/ 2>/dev/null ) || echo >/dev/null
#
#broadcast0 "$str"
#assertEqual "$str" 1

#type=`basename "$str" | cut -d'.' -f2`
#echo type: $type
#echo str: $str
              if [ "$act" = edit ];then
                gvim -f $file
                  cmd="source $file"
                  clear
                  echo 1>&2 "[re-loading] \n$cmd"
                  eval "$cmd"
              else
                source $file 2>/tmp/err || { echo /tmp/err; cat /tmp/err; }
  fi

    res=$?
#echo -n 1>&2 $res 
#popd >/dev/null
            else
              echo 1>&2 "not a file: $file"
                fi
        else

          echo -e 1>&2 "\n[CALLER] $str_caller"
            echo 1>&2 "finder return empty string for: $str0"
            fi
            set +e
            set +u
            return $res

}
export -f use
export -f use_many
