#https://launchpad.net/~kamalmostafa/+archive/ubuntu/linux-kamal-mjgbacklight
#https://wiki.archlinux.org/index.php/backlight
#kill bg job:
#https://wiki.ubuntu.com/NotifyOSD
#travis syntax: http://lint.travis-ci.org/
#http://www.grymoire.com/Unix/Sed.html
#http://www.grymoire.com/Unix/Sed.html
#defult: load where_amn_i
shopt -s expand_aliases
set -u
assertEquals(){
    echo $@
    exit 0
    }
lock_set(){
alias set='true'
#echo '[set-not-enable!]'; $cmd_caller'
}


export MODE_TEST=${MODE_TEST:-false}
ensure_use(){
export file_use="$dir_CODE/use.cfg"
  #register $file
  source $file_use

  export file_use_sh="$dir_CODE/use_sh.cfg"
  #register $file
  source $file_use_sh
}

trap_exit1(){
 #   print_line0
    echo 1>&2 "$FUNCNAME: $?"
   # commander0 cowsay  
    echo 1>&2 "[CALLER] $( $cmd_caller )"
    test -f /tmp/err && { cat 1>&2 /tmp/err; rm /tmp/err; } || true
    unalias set
trap - ERR
#trap - EXIT
    set +u
    set +e
    #return 0
    true
}
export -f trap_exit1
trap trap_exit1 EXIT
###############################################
expose_funcs(){
    echo 1>&2 $FUNCNAME
    cat $BASH_SOURCE | grep '(){' | sed 's/(){//g' | grep -v grep
}
where_am_i () 
{ 
  local file=${1:-"${BASH_SOURCE[0]}"};
  local rpath=$(readlink -m $file);
  local rcommand=${rpath##*/};
  local str_res=${rpath%/*};
  echo $str_res
  #local dir_self=$( cd $str_res  && echo $PWD )
  #echo "$dir_self"
}



later0(){
LIBRARY_LOADED=${LIBRARY_LOADED:-false}
set +e
MODE_TEST=${MODE_TEST:-false}
if [ $MODE_TEST = false ];then
( test $LIBRARY_LOADED = true ) && { echo 1>&2 library already loaded; return 0; }
fi

}

set_args(){
#https://wiki.ubuntu.com/DashAsBinSh
#commander "assert left_bigger $# 1"
local arg0=$1
local opts="${@:1}"
print color 34 "arg0: $arg0"
print color 34 "opts: $opts"
}

set_env_for_testing(){
  #export MODE_TEST=false
  export cmd_WTF='eval echo "Error ! $LINENO $BASH_LINENO"; sleep 5'
  export delay_testing=0.2
}

library_about(){
  print func
  print color 33 FUNCS
  print_g pv '----------------------------------'
  commander "cat $BASH_SOURCE | grep 'export -f' | sed 's/export -f//g'"
  print line
  print color 33 VARS 

  print_g pv '----------------------------------'
  commander "cat $BASH_SOURCE | grep 'export' | grep -v 'export -f' | sed 's/export//g'"

  print line
  print color 33 USE

  print_g pv '----------------------------------'
  cat $BASH_SOURCE | grep use | grep -v grep
}

switch_to(){
#useful when we need to visit again then same url we may already opened using the browser
print func
  depend wmctrl 


  local switch_name="$1"
  local cmd="$2"

  ( commander "wmctrl -a $switch_name" ) || ( commander open_with "$cmd" )
}

broadcast(){
  notify-send "$1" "$2" -u critical -t 7000
}


set_env_basic(){
  SHELL=/bin/bash
  PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin:/usr/games
  TERM=xterm
  #DISPLAY=:0 


}

log321(){
  local line="$(date +%H:%M) | $0 | $@"
  echo "$line"  >> /tmp/library.log
}


#alias idea='vim ~/idea.yaml'
######################################## traps #############

reminder(){
  set +e
  clear
  print_g pv $FUNCNAME
  #type $FUNCNAME
  #echo find . -name "*.[ch]" -exec grep -i -H ÃŸearch pharse {} ;
  #echo find -not -empty -type f -printf "%s\n" | sort -rn | uniq -d | xargs -I{} -n1
  #echo find -type f -size {}c -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate
  library_about
}

#############################################################


subshell(){
  clear

  print color 33 '[jail] run safely:'
  print line
  set +e
  ( commander $@ )
  echo 
  print line
}

finder_cd(){
#goto dir which has this filename/funcname   
print func
local str=$( commander finder $@ )
commander "cd $( dirname $str )"
}
finder(){
  local util="$dir_CODE/find.sh"
  local str="$1"
  local type="${2:-cfg}"
  local cmd="$util $str $type"
  eval "$cmd" 2>/tmp/err 
  local res=$?
  # test $res -eq 0 || (  echo cat /tmp/err; )
  return $res
}


install_anchor(){
  #export
  local filename file_self file_to
  local filename=$( basename $BASH_SOURCE )
  local file_self="$dir_library/$filename"
  local file_to=/tmp/$filename
  local dir_to=/tmp/dir_library
  #install an anchor for any other projects which may use this library 
  if [ ! -L $file_to ] ;then
    ln -s $file_self $file_to
  fi
  if [ ! -d $dir_to ];then
      ln -s $dir_library $dir_target
      fi
  }
  
ensure_workspace(){
if [ ! -d $dir_workspace ];then
    mkdir -p $dir_workspace
fi
}





export_vars(){

	export LOGNAME=${LOGNAME:-user1}
  if [ $LOGNAME = travis ];then
    echo   export AUDIODEV=null #travis - fix: no audio device 
  fi

  export PATH=$PATH:/usr/local/bin
  export gxmessage1='gxmessage -file /tmp/err -title cmd_err -sticky -ontop -timeout 10'

export pidof1='pidof -x $( basename $0 )'
   }
 struct1(){


    test -d $dir_library || { $cmd_caller;  return 1; }
  export dir_CODE=$dir_library/BANK #shorter name
export dir_workspace=$HOME/.config/do_for_others_first
  export file_updatedb="$dir_CODE/updatedb.sh" #index of files under the parent dir
  test -d $dir_CODE

     }
export_funcs(){
  local file
  export -f finder
export -f set_args
export -f hotkey_overide

  export -f finder_cd
export -f where_am_i
  export -f activate_important
  export -f switch_to
  export -f broadcast
  export -f log321
  export -f subshell 
  }


aliases(){
  alias libraryE="vi $BASH_SOURCE"
  alias libraryS="source $BASH_SOURCE"

  alias cd_library='cd $dir_library'
  alias updatedb2='$file_updatedb'
  ############# other method for aliasing:

  }

activate_important(){
    print func
  set -u
  #echo 1>&2 $BASH_SOURCE
###############################################
  #printing nicer
  type use 1>/dev/null || { echo 1>&2 "[ERR] func not found: use()"; return 1; }
  use ps1
use open_with
use where_am_i
use who_am_i
  use ps4
  use indicator
  use print
use point
use python1
use disown1
use sanitize
  use traps
  use trace
  use expose_var
###############################################
  #workflow 
  use commander
  use exiting
  use dialog_optional
###############################################
  #useful for reminding every X times
  use random
###############################################
  #test operator wrapper
  use assert
  use ensure
###############################################
  #shell navigation
  use history_sync
  use quick_follow
  use quick_remember
  use register
###############################################
  #user custom parameters
  use vars
use mode
  use alias
###############################################
  #file print/update
  use cat1
  use file_update
###############################################
#start using what sourced
register $file_use
  register $file_use_sh

  print ok Activated Important stuff
  set +e
  set +o nounset
}
testing(){
  #test -v MODE_TEST
  local file
  if [ "$MODE_TEST" = true ];then
    file=$(mktemp)
    print func
    use register
    subshell register $file_use

    register $file_use_sh


    #ensure touch $file
    #register $file
    #alias | grep $file
    #    indicator
  else
    print color 34 'skip testing'
  fi
}
ensure_index(){
  if [ ! -f /tmp/target ] || [ ! -s /tmp/target ];then
    echo 1>&2 creating index of library files..
    $dir_CODE/updatedb.sh
  fi
}

step(){
  local cmd="$@"
  cmd="$@"
  local delay=${delay_testing:-0.1}
  if [ $MODE_TEST = true ];then
    echo 1>&2 "$cmd"
    sleep $delay
  fi
  set +e
  {  eval "$cmd" || $cmd_WTF; }
}
hotkey_overide(){

commander "assert left_bigger $# 1"
set +e
(

local desc="$1"

shift
local cmd="$@"

#xcowsay "hotkey: ctrl+F2: $desc" &
local file=/tmp/hotkey_overide.sh
commander touch $file
commander "echo \"xcowsay '$desc';$cmd\" > $file"
commander chmod u+x $file
cat1 $file true
commander "assert file_has_content $file"
)
echo
}
step11(){
local step=$1
echo "[step] $step"
eval "$step" || { return 1; }
}

steps_for_lib(){
  #type $FUNCNAME

  step export_vars #dir_library, file_library , dir_CODE( the library BANK/)
  step struct1
#  assertEquals $dir_CODE ''

  step ensure_use
  step install_anchor #/tmp/library.cfg
  step ensure_workspace
  step ensure_index #index of library files: /tmp/target
  step export_funcs #
  step aliases  #updatedb+edit self+cd self
  #set_env_basic
  #echo step using #utilize: use()
  #using #utilize: use()
}

later(){
alias step2='activate_important'
alias vi=vim


#( blaaah || $cmd_WTF )
steps_for_lib || $cmd_WTF
activate_important || $cmd_WTF
( testing ) || print error 
#( test ( random 20 ) -eq 0 )  && reminder
trap - ERR
trap - EXIT
set +u
set +e
export LIBRARY_LOADED=true
}
test_something(){
    cd /tmp
echo "where_am_i $(     where_am_i )"
    }
#test_something
#expose_funcs
test1(){
steps_for_lib
activate_important
}


export str_caller='eval echo $( caller )'
  export cmd_caller='eval echo $( caller )'

      export dir_library=$(where_am_i $BASH_SOURCE)
      echo 1>&2 dir_library: $dir_library 
#      exit 0


 set_env_for_testing 
lock_set
test1 || { echo 1>&2 "[ERROR]"; }


    unalias set
trap - ERR
#trap - EXIT
set +u
set +e

